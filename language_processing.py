"""
Language Processing Module for LangGen
Contains: Language validation, interpreter generation, code execution, and template processing
"""

import json
import os
import sys
import re
import random
import time
import threading
from datetime import datetime
from typing import Dict, List, Any, Optional
import tkinter as tk
from tkinter import messagebox

class LanguageValidator:
    """Handles language definition validation and syntax checking"""
    
    @staticmethod
    def validate_language_data(data):
        """Validate loaded language data"""
        required_fields = ['name', 'version', 'author']
        return all(field in data for field in required_fields)
    
    @staticmethod
    def validate_syntax_advanced(language_data):
        """Enhanced syntax validation with detailed checking"""
        issues = []
        warnings = []
        
        # Check required elements
        if not language_data.get('name') or language_data['name'] == 'MyLang':
            issues.append("Language needs a unique name")
        
        keywords = language_data.get('keywords', {})
        if len([k for k in keywords.values() if k]) < 3:
            issues.append("At least 3 keywords should be defined")
        
        builtins = language_data.get('builtins', {})
        if not builtins.get('print'):
            warnings.append("Consider defining a print/output function")
        
        # Check for conflicts
        all_words = list(keywords.values()) + list(builtins.values())
        all_words = [w for w in all_words if w]
        if len(all_words) != len(set(all_words)):
            issues.append("Some keywords/functions have the same name")
        
        return issues, warnings

class InterpreterGenerator:
    """Generates complete working interpreters for custom languages"""
    
    def __init__(self, language_data):
        self.language_data = language_data
    
    def generate_interpreter(self, export_folder):
        """Generate a complete working interpreter for the language"""
        lang_name = self.language_data['name'].lower().replace(' ', '_')
        interpreter_file = os.path.join(export_folder, 'src', f'{lang_name}.py')
        
        # Generate the complete interpreter code
        interpreter_code = f'''#!/usr/bin/env python3
"""
{self.language_data['name']} Interpreter
Generated by SUPER Language Creator
Version: {self.language_data.get('version', '1.0')}
Author: {self.language_data.get('author', 'Unknown')}
"""

import json
import sys
import os
import re
import random
from typing import Dict, List, Any, Optional

class {self.language_data['name'].replace(' ', '')}Interpreter:
    def __init__(self, language_file='language.json'):
        self.language_file = language_file
        self.load_language_definition()
        self.variables = {{}}
        self.functions = {{}}
        self.call_stack = []
        self.output_buffer = []
        
    def load_language_definition(self):
        """Load the language definition from JSON"""
        script_dir = os.path.dirname(os.path.abspath(__file__))
        lang_path = os.path.join(os.path.dirname(script_dir), self.language_file)
        
        with open(lang_path, 'r', encoding='utf-8') as f:
            self.lang_def = json.load(f)
        
        # Extract keywords and builtins
        self.keywords = self.lang_def.get('keywords', {{}})
        self.builtins = self.lang_def.get('builtins', {{}})
        self.errors = self.lang_def.get('errors', {{}})
        
        # Create reverse mappings (custom -> english)
        self.keyword_map = {{v: k for k, v in self.keywords.items() if v}}
        self.builtin_map = {{v: k for k, v in self.builtins.items() if v}}
    
    def tokenize(self, code: str) -> List[Dict[str, Any]]:
        """Tokenize the source code"""
        tokens = []
        lines = code.split('\\n')
        
        for line_num, line in enumerate(lines, 1):
            # Skip empty lines and comments
            stripped = line.strip()
            if not stripped or stripped.startswith('#'):
                continue
            
            # Tokenize the line
            pattern = r'("(?:[^"\\\\]|\\\\.)*"|\\\'(?:[^\\\'\\\\]|\\\\.)*\\\'|[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+\\.?[0-9]*|==|!=|<=|>=|&&|\\|\\||[+\\-*/=<>(){{}}\\[\\],])'
            
            matches = re.findall(pattern, line)
            col = 0
            
            for match in matches:
                token_type = self.get_token_type(match)
                tokens.append({{
                    'type': token_type,
                    'value': match,
                    'line': line_num,
                    'column': col
                }})
                col += len(match) + 1
        
        return tokens
    
    def get_token_type(self, token: str) -> str:
        """Determine the type of a token"""
        # Check if it's a keyword
        if token in self.keyword_map:
            return f'KEYWORD_{{self.keyword_map[token].upper()}}'
        
        # Check if it's a builtin function
        if token in self.builtin_map:
            return f'BUILTIN_{{self.builtin_map[token].upper()}}'
        
        # Check for literals
        if token.startswith('"') or token.startswith("'"):
            return 'STRING'
        
        if re.match(r'^[0-9]+\\.?[0-9]*$', token):
            return 'NUMBER'
        
        # Check for operators
        operators = {{
            self.lang_def.get('operators', {{}}).get('addition', '+'): 'PLUS', 
            self.lang_def.get('operators', {{}}).get('subtraction', '-'): 'MINUS', 
            self.lang_def.get('operators', {{}}).get('multiplication', '*'): 'MULTIPLY', 
            self.lang_def.get('operators', {{}}).get('division', '/'): 'DIVIDE',
            self.lang_def.get('operators', {{}}).get('assign', '='): 'ASSIGN', 
            self.lang_def.get('operators', {{}}).get('equal', '=='): 'EQUALS', 
            self.lang_def.get('operators', {{}}).get('not_equal', '!='): 'NOT_EQUALS',
            self.lang_def.get('operators', {{}}).get('less_than', '<'): 'LESS', 
            self.lang_def.get('operators', {{}}).get('greater_than', '>'): 'GREATER', 
            self.lang_def.get('operators', {{}}).get('less_equal', '<='): 'LESS_EQUAL', 
            self.lang_def.get('operators', {{}}).get('greater_equal', '>='): 'GREATER_EQUAL',
            self.lang_def.get('operators', {{}}).get('and', '&&'): 'AND', 
            self.lang_def.get('operators', {{}}).get('or', '||'): 'OR'
        }}
        
        if token in operators:
            return operators[token]
        
        # Check for delimiters
        delimiters = {{
            '(': 'LPAREN', ')': 'RPAREN',
            '{{': 'LBRACE', '}}': 'RBRACE',
            '[': 'LBRACKET', ']': 'RBRACKET',
            ',': 'COMMA'
        }}
        
        if token in delimiters:
            return delimiters[token]
        
        # Check for boolean values
        if token == self.builtins.get('true', 'true'):
            return 'TRUE'
        if token == self.builtins.get('false', 'false'):
            return 'FALSE'
        
        # Otherwise it's an identifier
        return 'IDENTIFIER'
    
    def parse(self, tokens: List[Dict[str, Any]]):
        """Parse tokens into an AST"""
        self.tokens = tokens
        self.current = 0
        return self.parse_program()
    
    def parse_program(self):
        """Parse the entire program"""
        statements = []
        while not self.is_at_end():
            stmt = self.parse_statement()
            if stmt:
                statements.append(stmt)
        return {{'type': 'PROGRAM', 'statements': statements}}
    
    def parse_statement(self):
        """Parse a single statement"""
        if self.match('KEYWORD_VARIABLE'):
            return self.parse_variable_declaration()
        elif self.match('KEYWORD_FUNCTION'):
            return self.parse_function_declaration()
        elif self.match('KEYWORD_IF'):
            return self.parse_if_statement()
        elif self.match('KEYWORD_LOOP'):
            return self.parse_loop_statement()
        elif self.match('KEYWORD_RETURN'):
            return self.parse_return_statement()
        elif self.check_type('BUILTIN_PRINT'):
            return self.parse_expression_statement()
        elif self.check_type('IDENTIFIER'):
            # Could be assignment or function call
            return self.parse_expression_statement()
        else:
            self.advance()  # Skip unknown tokens
            return None
    
    def parse_variable_declaration(self):
        """Parse variable declaration"""
        name = self.consume('IDENTIFIER', 'Expected variable name')
        
        if self.match('ASSIGN'):
            value = self.parse_expression()
            return {{'type': 'VAR_DECL', 'name': name['value'], 'value': value}}
        
        return {{'type': 'VAR_DECL', 'name': name['value'], 'value': None}}
    
    def parse_function_declaration(self):
        """Parse function declaration"""
        name = self.consume('IDENTIFIER', 'Expected function name')
        
        self.consume('LPAREN', 'Expected ( after function name')
        
        params = []
        if not self.check('RPAREN'):
            params.append(self.consume('IDENTIFIER', 'Expected parameter name')['value'])
            while self.match('COMMA'):
                params.append(self.consume('IDENTIFIER', 'Expected parameter name')['value'])
        
        self.consume('RPAREN', 'Expected ) after parameters')
        self.consume('LBRACE', 'Expected {{ before function body')
        
        body = []
        while not self.check('RBRACE') and not self.is_at_end():
            stmt = self.parse_statement()
            if stmt:
                body.append(stmt)
        
        self.consume('RBRACE', 'Expected }} after function body')
        
        return {{
            'type': 'FUNC_DECL',
            'name': name['value'],
            'params': params,
            'body': body
        }}
    
    def parse_if_statement(self):
        """Parse if statement"""
        condition = self.parse_expression()
        
        self.consume('LBRACE', 'Expected {{ after if condition')
        then_branch = []
        
        while not self.check('RBRACE') and not self.is_at_end():
            stmt = self.parse_statement()
            if stmt:
                then_branch.append(stmt)
        
        self.consume('RBRACE', 'Expected }} after if body')
        
        else_branch = None
        if self.match('KEYWORD_ELSE'):
            if self.match('KEYWORD_IF'):
                # else if
                else_branch = [self.parse_if_statement()]
            else:
                self.consume('LBRACE', 'Expected {{ after else')
                else_branch = []
                
                while not self.check('RBRACE') and not self.is_at_end():
                    stmt = self.parse_statement()
                    if stmt:
                        else_branch.append(stmt)
                
                self.consume('RBRACE', 'Expected }} after else body')
        
        return {{
            'type': 'IF_STMT',
            'condition': condition,
            'then_branch': then_branch,
            'else_branch': else_branch
        }}
    
    def parse_loop_statement(self):
        """Parse loop statement"""
        condition = self.parse_expression()
        
        self.consume('LBRACE', 'Expected {{ after loop condition')
        body = []
        
        while not self.check('RBRACE') and not self.is_at_end():
            stmt = self.parse_statement()
            if stmt:
                body.append(stmt)
        
        self.consume('RBRACE', 'Expected }} after loop body')
        
        return {{
            'type': 'LOOP_STMT',
            'condition': condition,
            'body': body
        }}
    
    def parse_return_statement(self):
        """Parse return statement"""
        value = None
        if not self.is_at_end() and not self.check('RBRACE'):
            value = self.parse_expression()
        
        return {{'type': 'RETURN_STMT', 'value': value}}
    
    def parse_expression_statement(self):
        """Parse expression statement"""
        expr = self.parse_expression()
        
        # Check if it's an assignment
        if self.match('ASSIGN'):
            if expr['type'] != 'IDENTIFIER':
                self.error('Invalid assignment target')
            
            value = self.parse_expression()
            return {{'type': 'ASSIGN', 'name': expr['value'], 'value': value}}
        
        return {{'type': 'EXPR_STMT', 'expression': expr}}
    
    def parse_expression(self):
        """Parse expression"""
        return self.parse_logical_or()
    
    def parse_logical_or(self):
        """Parse logical OR expression"""
        expr = self.parse_logical_and()
        
        while self.match('OR'):
            op = self.previous()
            right = self.parse_logical_and()
            expr = {{'type': 'BINARY', 'left': expr, 'operator': op['type'], 'right': right}}
        
        return expr
    
    def parse_logical_and(self):
        """Parse logical AND expression"""
        expr = self.parse_equality()
        
        while self.match('AND'):
            op = self.previous()
            right = self.parse_equality()
            expr = {{'type': 'BINARY', 'left': expr, 'operator': op['type'], 'right': right}}
        
        return expr
    
    def parse_equality(self):
        """Parse equality expression"""
        expr = self.parse_comparison()
        
        while self.match('EQUALS', 'NOT_EQUALS'):
            op = self.previous()
            right = self.parse_comparison()
            expr = {{'type': 'BINARY', 'left': expr, 'operator': op['type'], 'right': right}}
        
        return expr
    
    def parse_comparison(self):
        """Parse comparison expression"""
        expr = self.parse_addition()
        
        while self.match('GREATER', 'GREATER_EQUAL', 'LESS', 'LESS_EQUAL'):
            op = self.previous()
            right = self.parse_addition()
            expr = {{'type': 'BINARY', 'left': expr, 'operator': op['type'], 'right': right}}
        
        return expr
    
    def parse_addition(self):
        """Parse addition/subtraction expression"""
        expr = self.parse_multiplication()
        
        while self.match('PLUS', 'MINUS'):
            op = self.previous()
            right = self.parse_multiplication()
            expr = {{'type': 'BINARY', 'left': expr, 'operator': op['type'], 'right': right}}
        
        return expr
    
    def parse_multiplication(self):
        """Parse multiplication/division expression"""
        expr = self.parse_unary()
        
        while self.match('MULTIPLY', 'DIVIDE'):
            op = self.previous()
            right = self.parse_unary()
            expr = {{'type': 'BINARY', 'left': expr, 'operator': op['type'], 'right': right}}
        
        return expr
    
    def parse_unary(self):
        """Parse unary expression"""
        if self.match('MINUS'):
            op = self.previous()
            expr = self.parse_unary()
            return {{'type': 'UNARY', 'operator': op['type'], 'operand': expr}}
        
        return self.parse_primary()
    
    def parse_primary(self):
        """Parse primary expression"""
        # Boolean literals
        if self.match('TRUE'):
            return {{'type': 'LITERAL', 'value': True}}
        
        if self.match('FALSE'):
            return {{'type': 'LITERAL', 'value': False}}
        
        # Number literal
        if self.match('NUMBER'):
            value = self.previous()['value']
            return {{'type': 'LITERAL', 'value': float(value) if '.' in value else int(value)}}
        
        # String literal
        if self.match('STRING'):
            value = self.previous()['value'][1:-1]  # Remove quotes
            return {{'type': 'LITERAL', 'value': value}}
        
        # Function call or identifier
        if self.check_type('BUILTIN') or self.check_type('IDENTIFIER'):
            token = self.advance()
            
            # Check if it's a function call
            if self.match('LPAREN'):
                args = []
                
                if not self.check('RPAREN'):
                    args.append(self.parse_expression())
                    while self.match('COMMA'):
                        args.append(self.parse_expression())
                
                self.consume('RPAREN', 'Expected ) after arguments')
                
                return {{
                    'type': 'CALL',
                    'callee': token['value'],
                    'arguments': args,
                    'is_builtin': token['type'].startswith('BUILTIN')
                }}
            
            # Just an identifier
            return {{'type': 'IDENTIFIER', 'value': token['value']}}
        
        # Grouped expression
        if self.match('LPAREN'):
            expr = self.parse_expression()
            self.consume('RPAREN', 'Expected ) after expression')
            return expr
        
        self.error(f"Unexpected token: {{self.peek()['value'] if not self.is_at_end() else 'EOF'}}")
    
    def execute(self, ast):
        """Execute the AST"""
        try:
            self.execute_node(ast)
            return '\\n'.join(self.output_buffer)
        except Exception as e:
            return f"Runtime error: {{str(e)}}"
    
    def execute_node(self, node):
        """Execute a single AST node"""
        if node is None:
            return None
        
        node_type = node.get('type')
        
        if node_type == 'PROGRAM':
            for stmt in node['statements']:
                result = self.execute_node(stmt)
                if isinstance(result, dict) and result.get('type') == 'RETURN':
                    return result
        
        elif node_type == 'VAR_DECL':
            value = None
            if node['value']:
                value = self.execute_node(node['value'])
            self.variables[node['name']] = value
        
        elif node_type == 'FUNC_DECL':
            self.functions[node['name']] = node
        
        elif node_type == 'IF_STMT':
            condition = self.execute_node(node['condition'])
            if self.is_truthy(condition):
                for stmt in node['then_branch']:
                    result = self.execute_node(stmt)
                    if isinstance(result, dict) and result.get('type') == 'RETURN':
                        return result
            elif node['else_branch']:
                for stmt in node['else_branch']:
                    result = self.execute_node(stmt)
                    if isinstance(result, dict) and result.get('type') == 'RETURN':
                        return result
        
        elif node_type == 'LOOP_STMT':
            while self.is_truthy(self.execute_node(node['condition'])):
                for stmt in node['body']:
                    result = self.execute_node(stmt)
                    if isinstance(result, dict) and result.get('type') == 'RETURN':
                        return result
        
        elif node_type == 'RETURN_STMT':
            value = None
            if node['value']:
                value = self.execute_node(node['value'])
            return {{'type': 'RETURN', 'value': value}}
        
        elif node_type == 'EXPR_STMT':
            self.execute_node(node['expression'])
        
        elif node_type == 'ASSIGN':
            value = self.execute_node(node['value'])
            self.variables[node['name']] = value
        
        elif node_type == 'BINARY':
            left = self.execute_node(node['left'])
            right = self.execute_node(node['right'])
            
            operators = {{
                'PLUS': lambda: left + right,
                'MINUS': lambda: left - right,
                'MULTIPLY': lambda: left * right,
                'DIVIDE': lambda: left / right if right != 0 else self.error("Division by zero"),
                'EQUALS': lambda: left == right,
                'NOT_EQUALS': lambda: left != right,
                'LESS': lambda: left < right,
                'GREATER': lambda: left > right,
                'LESS_EQUAL': lambda: left <= right,
                'GREATER_EQUAL': lambda: left >= right,
                'AND': lambda: self.is_truthy(left) and self.is_truthy(right),
                'OR': lambda: self.is_truthy(left) or self.is_truthy(right)
            }}
            
            return operators[node['operator']]()
        
        elif node_type == 'UNARY':
            operand = self.execute_node(node['operand'])
            if node['operator'] == 'MINUS':
                return -operand
        
        elif node_type == 'LITERAL':
            return node['value']
        
        elif node_type == 'IDENTIFIER':
            if node['value'] in self.variables:
                return self.variables[node['value']]
            else:
                self.error(f"Undefined variable: {{node['value']}}")
        
        elif node_type == 'CALL':
            return self.execute_call(node)
        
        return None
    
    def execute_call(self, node):
        """Execute a function call"""
        callee = node['callee']
        args = [self.execute_node(arg) for arg in node['arguments']]
        
        if node['is_builtin']:
            return self.execute_builtin(callee, args)
        elif callee in self.functions:
            return self.execute_user_function(self.functions[callee], args)
        else:
            self.error(f"Undefined function: {{callee}}")
    
    def execute_builtin(self, name, args):
        """Execute built-in function"""
        # Map custom name to standard function
        builtin_type = self.builtin_map.get(name, name)
        
        if builtin_type == 'print':
            output = ' '.join(str(arg) for arg in args)
            self.output_buffer.append(output)
            return None
        
        elif builtin_type == 'input':
            prompt = args[0] if args else ""
            return input(str(prompt))
        
        elif builtin_type == 'length':
            if args:
                return len(str(args[0]))
            return 0
        
        elif builtin_type == 'string':
            if args:
                return str(args[0])
            return ""
        
        elif builtin_type == 'number':
            if args:
                try:
                    return float(args[0]) if '.' in str(args[0]) else int(args[0])
                except:
                    return 0
            return 0
        
        elif builtin_type == 'random':
            if len(args) >= 2:
                return random.randint(int(args[0]), int(args[1]))
            return random.random()
        
        else:
            self.error(f"Unknown built-in function: {{name}}")
    
    def execute_user_function(self, func_node, args):
        """Execute user-defined function"""
        # Create new scope
        old_vars = self.variables.copy()
        
        # Bind parameters
        for i, param in enumerate(func_node['params']):
            if i < len(args):
                self.variables[param] = args[i]
            else:
                self.variables[param] = None
        
        # Execute function body
        result = None
        for stmt in func_node['body']:
            stmt_result = self.execute_node(stmt)
            if isinstance(stmt_result, dict) and stmt_result.get('type') == 'RETURN':
                result = stmt_result['value']
                break
        
        # Restore scope
        self.variables = old_vars
        
        return result
    
    def is_truthy(self, value):
        """Determine if a value is truthy"""
        if value is None:
            return False
        if isinstance(value, bool):
            return value
        if isinstance(value, (int, float)):
            return value != 0
        if isinstance(value, str):
            return len(value) > 0
        return True
    
    # Parser helper methods
    def match(self, *types):
        """Check if current token matches any of the given types"""
        for token_type in types:
            if self.check(token_type):
                self.advance()
                return True
        return False
    
    def check(self, token_type):
        """Check if current token is of given type"""
        if self.is_at_end():
            return False
        return self.peek()['type'] == token_type
    
    def check_type(self, prefix):
        """Check if current token type starts with prefix"""
        if self.is_at_end():
            return False
        return self.peek()['type'].startswith(prefix)
    
    def advance(self):
        """Consume current token and return it"""
        if not self.is_at_end():
            self.current += 1
        return self.previous()
    
    def is_at_end(self):
        """Check if we're at end of tokens"""
        return self.current >= len(self.tokens)
    
    def peek(self):
        """Return current token without consuming"""
        if self.is_at_end():
            return None
        return self.tokens[self.current]
    
    def previous(self):
        """Return previous token"""
        return self.tokens[self.current - 1]
    
    def consume(self, token_type, message):
        """Consume token of given type or error"""
        if self.check(token_type):
            return self.advance()
        
        self.error(message)
    
    def error(self, message):
        """Raise a parser/runtime error"""
        token = self.peek()
        if token:
            raise Exception(f"{{message}} at line {{token['line']}}, column {{token['column']}}")
        else:
            raise Exception(message)
    
    def run_file(self, filename):
        """Run a source file"""
        try:
            with open(filename, 'r', encoding='utf-8') as f:
                source = f.read()
            
            # Tokenize
            tokens = self.tokenize(source)
            
            # Parse
            ast = self.parse(tokens)
            
            # Execute
            output = self.execute(ast)
            
            if output:
                print(output)
            
        except FileNotFoundError:
            print(f"Error: File '{{filename}}' not found")
        except Exception as e:
            print(f"Error: {{str(e)}}")

def main():
    """Main entry point"""
    if len(sys.argv) < 2:
        print(f"Usage: python {lang_name}.py <filename.{lang_name[:3]}>")
        print(f"\\nExample: python {lang_name}.py examples/hello.{lang_name[:3]}")
        return
    
    interpreter = {self.language_data['name'].replace(' ', '')}Interpreter()
    interpreter.run_file(sys.argv[1])

if __name__ == "__main__":
    main()
'''
        
        # Write the interpreter file
        with open(interpreter_file, 'w', encoding='utf-8') as f:
            f.write(interpreter_code)
        
        return interpreter_file

class CodeExecutor:
    """Handles code execution and simulation in the playground"""
    
    def __init__(self, language_data):
        self.language_data = language_data
    
    def execute_playground_code(self, code, output_callback=None):
        """Execute the playground code with enhanced simulation"""
        if not output_callback:
            output_callback = print
        
        output_callback("\\n" + "="*40 + "\\n")
        output_callback("üì§ OUTPUT:\\n\\n")
        
        # Enhanced code simulation
        print_func = self.language_data.get('builtins', {}).get('print', 'print')
        input_func = self.language_data.get('builtins', {}).get('input', 'input')
        
        lines = code.split('\\n')
        output_generated = False
        
        for line in lines:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            
            # Simulate print statements
            if print_func in line:
                # Extract content between quotes or parentheses
                matches = re.findall(r'["\']([^"\']*)["\']', line)
                if matches:
                    output_text = ' '.join(matches)
                    output_callback(f"{output_text}\\n")
                    output_generated = True
                else:
                    # Look for variables or expressions
                    parts = line.split(print_func)[1].strip()
                    if parts.startswith('(') and parts.endswith(')'):
                        content = parts[1:-1]
                        # Simple variable simulation
                        if ',' in content:
                            items = [item.strip().strip('"\'') for item in content.split(',')]
                            output_text = ' '.join(items)
                        else:
                            output_text = content.strip('"\'')
                        output_callback(f"{output_text}\\n")
                        output_generated = True
            
            # Simulate variable assignments
            var_keyword = self.language_data.get('keywords', {}).get('variable', 'var')
            if var_keyword in line and '=' in line:
                parts = line.split('=')
                if len(parts) == 2:
                    var_name = parts[0].replace(var_keyword, '').strip()
                    var_value = parts[1].strip().strip('"\'')
                    output_callback(f"üì¶ {var_name} = {var_value}\\n")
                    output_generated = True
        
        if not output_generated:
            output_callback("‚ú® Program completed successfully!\\n")
            output_callback("(No output produced)\\n")
        
        output_callback("\\n" + "="*40 + "\\n")
        output_callback("‚úÖ Execution finished!\\n")

class TemplateProcessor:
    """Handles code template loading and processing"""
    
    def __init__(self, language_data):
        self.language_data = language_data
    
    def get_templates(self):
        """Get available code templates"""
        return {
            'hello_world': '''# Hello World Example
{print}("Hello, World!")
{print}("Welcome to {lang_name}!")

{var} message = "Programming is fun!"
{print}(message)''',
            
            'calculator': '''# Simple Calculator
{func} add(a, b) {{
    {return} a + b
}}

{func} multiply(a, b) {{
    {return} a * b
}}

{var} x = 10
{var} y = 5

{print}("Addition:", add(x, y))
{print}("Multiplication:", multiply(x, y))''',
            
            'game': '''# Number Guessing Game
{print}("=== Guessing Game ===")
{print}("Guess a number between 1 and 10!")

{var} secret = 7
{var} guess = 0
{var} tries = 0

{loop} guess != secret {{
    guess = {number}({input}("Your guess: "))
    tries = tries + 1
    
    {if} guess < secret {{
        {print}("Too low! Try again.")
    }} {else} {if} guess > secret {{
        {print}("Too high! Try again.")
    }}
}}

{print}("Correct! You got it in", tries, "tries!")'''
        }
    
    def load_template(self, template_name):
        """Load a code template with language-specific keywords"""
        templates = self.get_templates()
        
        if template_name in templates:
            # Replace placeholders with actual language keywords
            template = templates[template_name]
            replacements = {
                '{lang_name}': self.language_data.get('name', 'MyLang'),
                '{print}': self.language_data.get('builtins', {}).get('print', 'print'),
                '{input}': self.language_data.get('builtins', {}).get('input', 'input'),
                '{number}': self.language_data.get('builtins', {}).get('number', 'number'),
                '{var}': self.language_data.get('keywords', {}).get('variable', 'var'),
                '{func}': self.language_data.get('keywords', {}).get('function', 'function'),
                '{if}': self.language_data.get('keywords', {}).get('if', 'if'),
                '{else}': self.language_data.get('keywords', {}).get('else', 'else'),
                '{loop}': self.language_data.get('keywords', {}).get('loop', 'loop'),
                '{return}': self.language_data.get('keywords', {}).get('return', 'return')
            }
            
            for placeholder, value in replacements.items():
                template = template.replace(placeholder, value)
            
            return template
        
        return None

class LanguageDataCollector:
    """Handles collection and validation of language data from UI"""
    
    def __init__(self, ui_entries, language_data):
        self.ui_entries = ui_entries
        self.language_data = language_data
    
    def collect_language_data(self):
        """Enhanced data collection with validation"""
        # Basic info with validation
        if hasattr(self.ui_entries, 'name_entry'):
            self.language_data['name'] = self.ui_entries.name_entry.get().strip() or "MyLang"
        if hasattr(self.ui_entries, 'version_entry'):
            self.language_data['version'] = self.ui_entries.version_entry.get().strip() or "1.0"
        if hasattr(self.ui_entries, 'author_entry'):
            self.language_data['author'] = self.ui_entries.author_entry.get().strip() or "Anonymous"
        if hasattr(self.ui_entries, 'desc_text'):
            self.language_data['description'] = self.ui_entries.desc_text.get('1.0', 'end-1c').strip()
        
        # Keywords
        self.language_data['keywords'] = {}
        if hasattr(self.ui_entries, 'keyword_entries'):
            for keyword, entry in self.ui_entries.keyword_entries.items():
                value = entry.get().strip()
                if value:
                    self.language_data['keywords'][keyword] = value
        
        # Built-ins
        self.language_data['builtins'] = {}
        if hasattr(self.ui_entries, 'builtin_entries'):
            for builtin, entry in self.ui_entries.builtin_entries.items():
                value = entry.get().strip()
                if value:
                    self.language_data['builtins'][builtin] = value
        
        # Features
        if hasattr(self.ui_entries, 'features'):
            self.language_data['features'] = {k: v.get() for k, v in self.ui_entries.features.items()}
        
        # Update timestamp
        self.language_data['modified'] = datetime.now().isoformat()
        
        return self.language_data
    
    def has_unsaved_changes(self, current_file=None):
        """Check if there are unsaved changes"""
        current_data = {}
        try:
            current_data = self.collect_language_data()
        except:
            return False
        
        # Compare with last saved state or default
        if current_file:
            try:
                with open(current_file, 'r', encoding='utf-8') as f:
                    saved_data = json.load(f)
                return current_data != saved_data
            except:
                return True
        
        # If no file, check if different from default
        default_data = {
            'name': 'MyLang',
            'version': '1.0',
            'author': 'Young Coder',
            'description': 'My awesome programming language!',
            'keywords': {},
            'operators': {},
            'builtins': {},
            'errors': {},
        }
        
        return any(current_data.get(key) != default_data.get(key) 
                  for key in default_data.keys())

class TestFileCreator:
    """Creates test runner scripts for languages"""
    
    def __init__(self, language_data):
        self.language_data = language_data
    
    def create_test_files(self, export_folder):
        """Create test runner scripts for the language"""
        lang_name = self.language_data['name'].lower().replace(' ', '_')
        
        # Create test runner script
        test_runner = f'''#!/usr/bin/env python3
"""
Test Runner for {self.language_data['name']}
Runs all .{lang_name[:3]} files in the examples directory
"""

import os
import sys
import subprocess
from pathlib import Path

def run_test(filename):
    """Run a single test file"""
    print(f"\\n{'='*50}")
    print(f"Running: {{filename}}")
    print('='*50)
    
    try:
        result = subprocess.run([
            sys.executable, 
            f'src/{lang_name}.py', 
            filename
        ], capture_output=True, text=True, cwd=os.path.dirname(__file__))
        
        if result.returncode == 0:
            print("‚úÖ SUCCESS")
            if result.stdout:
                print("Output:")
                print(result.stdout)
        else:
            print("‚ùå FAILED")
            if result.stderr:
                print("Error:")
                print(result.stderr)
                
    except Exception as e:
        print(f"‚ùå ERROR: {{e}}")

def main():
    """Run all tests"""
    examples_dir = Path(__file__).parent / "examples"
    
    if not examples_dir.exists():
        print("No examples directory found")
        return
    
    test_files = list(examples_dir.glob(f"*.{lang_name[:3]}"))
    
    if not test_files:
        print(f"No .{lang_name[:3]} files found in examples/")
        return
    
    print(f"Found {{len(test_files)}} test files")
    
    for test_file in test_files:
        run_test(test_file)
    
    print(f"\\n{'='*50}")
    print("All tests completed")

if __name__ == "__main__":
    main()
'''
        
        test_file = os.path.join(export_folder, 'run_tests.py')
        with open(test_file, 'w', encoding='utf-8') as f:
            f.write(test_runner)
        
        return test_file